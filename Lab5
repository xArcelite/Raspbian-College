import RPi.GPIO as GPIO 
import time

#Defining pins
CS = 5 
Clock = 25 
Address = 24 
DataOut = 23 

#setting up IR sensor for pi
GPIO.setmode(GPIO.BCM) 
GPIO.setwarnings(False) 
GPIO.setup(Clock,GPIO.OUT) 
GPIO.setup(Address,GPIO.OUT) 
GPIO.setup(CS,GPIO.OUT) 
GPIO.setup(DataOut,GPIO.IN,GPIO.PUD_UP)

#motor pins
IN1 = 12 
IN2 = 13 
IN3 = 20 
IN4 = 21 
EN1 = 6 
EN2 = 26 

#motor setup
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
GPIO.setup(IN1,GPIO.OUT)
GPIO.setup(IN2,GPIO.OUT)
GPIO.setup(IN3,GPIO.OUT)
GPIO.setup(IN4,GPIO.OUT)
GPIO.setup(EN1,GPIO.OUT)
GPIO.setup(EN2,GPIO.OUT)

#Set PWM
pa = GPIO.PWM(EN1,500)
pb = GPIO.PWM(EN2,500)
Pa.start(25)
Pb.start(25)

def backward(): 
init() 
GPIO.output(EN1,GPIO.HIGH)
GPIO.output(EN2,GPIO.HIGH) 
GPIO.output(IN2,GPIO.HIGH) 
GPIO.output(IN3,GPIO.HIGH)

GPIO.setmode(GPIO.BCM) 
GPIO.setwarnings(False) 

def AnalogRead():
  value = [0] * (self.numSensors + 1)
  #Read Channel0~channel6 AD value
  for j in range(0, self.numSensors + 1):
        GPIO.output(CS, GPIO.LOW)
             for i in range(0, 4):
                # sent 4-bit Address
                if (j >> (3 - i)) & 0x01:
                    GPIO.output(Address, GPIO.HIGH)
                else:
                    GPIO.output(Address, GPIO.LOW)
                # read MSB 4-bit data
                value[j] <<= 1
                if GPIO.input(DataOut):
                    value[j] |= 0x01
                GPIO.output(Clock, GPIO.HIGH)
                GPIO.output(Clock, GPIO.LOW)
            for i in range(0, 6):
                # read LSB 8-bit data
                value[j] <<= 1
                if GPIO.input(DataOut):
                    value[j] |= 0x01
                GPIO.output(Clock, GPIO.HIGH)
                GPIO.output(Clock, GPIO.LOW)
            # no mean ,just delay
            for i in range(0,6):
               GPIO.output(Clock, GPIO.HIGH)
               GPIO.output(Clock, GPIO.LOW)
            #time.sleep(0.0001)
            GPIO.output(CS, GPIO.HIGH)
        print value[1:]
        return value[1:]
       
def calibrate():
        max_sensor_values = [0]*self.numSensors
        min_sensor_values = [0]*self.numSensors
        for j in range(0, 10):
        
            sensor_values = self.AnalogRead()
            
            for i in range(0, self.numSensors):
            
                # set the max we found THIS time
                if (j == 0) or max_sensor_values[i] < sensor_values[i]:
                    max_sensor_values[i] = sensor_values[i]

                # set the min we found THIS time
                if (j == 0) or min_sensor_values[i] > sensor_values[i]:
                    min_sensor_values[i] = sensor_values[i]

        # record the min and max calibration values
        for i in range(0, self.numSensors):
            if min_sensor_values[i] > self.calibratedMin[i]:
                self.calibratedMin[i] = min_sensor_values[i]
            if max_sensor_values[i] < self.calibratedMax[i]:
                self.calibratedMax[i] = max_sensor_values[i]
                
def readCalibrated(self):
        value = 0
        # read the needed values
        sensor_values = self.AnalogRead()

        for i in range(0, self.numSensors):

            denominator = self.calibratedMax[i] - self.calibratedMin[i]

            if denominator != 0:
                value = (sensor_values[i] - self.calibratedMin[i]) * 1000 / denominator
                
            if value < 0:
                value = 0
            elif value > 1000:
                value = 1000
                
            sensor_values[i] = value
        
        # print("readCalibrated",sensor_values)
        return sensor_values
        
while(i==i):
	reading = readCalibrated()
	pos = posit(sva1)
	print(pos)
	if (reading
